import type { InsightBundle } from '@/lib/ai/types';
import type { PromptTemplateId } from '@/lib/guided-prompts';
import { STORAGE_KEYS } from '@/lib/storage-keys';
import { getRaw, setRaw } from '@/lib/vault';

const HISTORY_LIMIT = 100;

export interface StoredDraft {
  promptId: PromptTemplateId;
  entry: string;
  updatedAt: string;
}

export interface StoredEntry {
  id: string;
  promptId: PromptTemplateId;
  entry: string;
  wordCount: number;
  createdAt: string;
  insights?: InsightBundle | null;
  analyzedAt?: string | null;
}

function isBrowser() {
  return typeof window !== 'undefined';
}

function safeParse<T>(value: string | null): T | null {
  if (!value) return null;
  try {
    return JSON.parse(value) as T;
  } catch (error) {
    console.warn('[journal-storage] Failed to parse payload', error);
    return null;
  }
}

export async function loadDraft(): Promise<StoredDraft | null> {
  if (!isBrowser()) return null;
  const raw = await getRaw(STORAGE_KEYS.draft);
  return safeParse<StoredDraft>(raw);
}

export async function saveDraft(draft: StoredDraft | null) {
  if (!isBrowser()) return;
  await setRaw(STORAGE_KEYS.draft, draft ? JSON.stringify(draft) : null);
}

export async function loadHistory(): Promise<StoredEntry[]> {
  if (!isBrowser()) return [];
  const raw = await getRaw(STORAGE_KEYS.history);
  return safeParse<StoredEntry[]>(raw) ?? [];
}

export async function saveHistory(entries: StoredEntry[]) {
  if (!isBrowser()) return;
  await setRaw(STORAGE_KEYS.history, JSON.stringify(entries));
}

export async function addHistoryEntry(
  entry: StoredEntry,
  limit = HISTORY_LIMIT
): Promise<StoredEntry[]> {
  const current = await loadHistory();
  const next = [entry, ...current].slice(0, limit);
  await saveHistory(next);
  return next;
}

export async function updateHistoryEntry(
  entryId: string,
  updater: (current: StoredEntry) => StoredEntry,
  limit = HISTORY_LIMIT
): Promise<StoredEntry[]> {
  const current = await loadHistory();
  const next = current
    .map((entry) => (entry.id === entryId ? updater(entry) : entry))
    .slice(0, limit);
  await saveHistory(next);
  return next;
}

export async function deleteHistoryEntry(
  entryId: string
): Promise<StoredEntry[]> {
  const current = await loadHistory();
  const next = current.filter((entry) => entry.id !== entryId);
  await saveHistory(next);
  return next;
}

export async function clearHistory() {
  if (!isBrowser()) return;
  await setRaw(STORAGE_KEYS.history, null);
}

export async function exportHistoryAsJSON(): Promise<string> {
  const history = await loadHistory();
  return JSON.stringify(history, null, 2);
}

export async function exportHistoryAsMarkdown(): Promise<string> {
  const history = await loadHistory();

  if (history.length === 0) {
    return '# Journal History\n\nNo entries yet.';
  }

  const lines: string[] = [
    '# Journal History',
    '',
    `Generated: ${new Date().toLocaleDateString()}`,
    '',
    `Total Entries: ${history.length}`,
    '',
    '---',
    '',
  ];

  history.forEach((entry, index) => {
    const date = new Date(entry.createdAt);
    const dateStr = date.toLocaleDateString(undefined, {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });

    lines.push(`## Entry ${history.length - index}`);
    lines.push('');
    lines.push(`**Date:** ${dateStr}`);
    lines.push(`**Created At (ISO):** ${entry.createdAt}`);
    lines.push(`**ID:** ${entry.id}`);
    lines.push(`**Word Count:** ${entry.wordCount}`);
    lines.push(`**Prompt:** ${entry.promptId}`);
    lines.push('');
    lines.push('### Content');
    lines.push('');
    lines.push(entry.entry);
    lines.push('');

    if (entry.insights) {
      lines.push('### AI Insights');
      lines.push('');
      lines.push(
        `**Emotion:** ${entry.insights.emotion.emoji} ${entry.insights.emotion.tone}`
      );
      lines.push(`> ${entry.insights.emotion.text}`);
      lines.push('');
      lines.push(`**Theme:** ${entry.insights.theme.text}`);
      lines.push('');
      lines.push(
        `**Reflection Question:** ${entry.insights.reflection.question}`
      );
      lines.push('');
    } else {
      lines.push('### AI Insights');
      lines.push('');
      lines.push('*Not analyzed yet.*');
      lines.push('');
    }
    lines.push('---');
    lines.push('');
  });

  lines.push('');
  lines.push(
    '*Generated by [journalingtechniques.ai](https://journalingtechniques.ai) - 100% Private AI Journaling*'
  );

  return lines.join('\n');
}

export function downloadFile(
  content: string,
  filename: string,
  mimeType: string
) {
  if (!isBrowser()) return;

  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export async function exportHistory(format: 'json' | 'markdown') {
  const timestamp = new Date().toISOString().split('T')[0];

  if (format === 'json') {
    const content = await exportHistoryAsJSON();
    downloadFile(
      content,
      `journal-history-${timestamp}.json`,
      'application/json'
    );
  } else {
    const content = await exportHistoryAsMarkdown();
    downloadFile(content, `journal-history-${timestamp}.md`, 'text/markdown');
  }
}
